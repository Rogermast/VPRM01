<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VPRM01 - GPS Fotos → Excel + KMZ (Local)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

  <style>
    :root{
      --card:#111a2e; --text:#e9eefc; --muted:#aab6d8; --line:#1c2a4a;
      --btn:#2a3e78; --btn2:#3853a6; --ok:#1f7a55;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#08101f,#0b1220);color:var(--text);}
    .wrap{max-width:1100px;margin:0 auto;padding:28px 16px 40px;}
    .card{background:rgba(17,26,46,.9);border:1px solid var(--line);border-radius:16px;padding:18px;box-shadow:0 10px 25px rgba(0,0,0,.25);}
    h1{margin:0 0 6px;font-size:22px} h2{margin:0 0 10px;font-size:18px}
    .muted{color:var(--muted); margin:8px 0 0; line-height:1.4}
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:14px;margin-top:14px;}
    label{display:block;margin-top:8px;margin-bottom:6px;color:var(--muted);font-size:13px}
    input{width:100%;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#0c1426;color:var(--text);outline:none;}
    button{margin-top:10px;width:100%;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:var(--btn);color:var(--text);font-weight:600;cursor:pointer;}
    button:hover{background:var(--btn2)} button.primary{background:var(--ok);} button.primary:hover{filter:brightness(1.1)}
    .actions{display:flex;gap:10px;margin-top:12px;}
    .linkbtn{display:inline-block;flex:1;text-align:center;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#0c1426;color:var(--text);text-decoration:none;font-weight:600;}
    .linkbtn:hover{background:#132042}
    .stats{margin-top:10px;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#0c1426;line-height:1.6;}
    #map{width:100%;height:460px;border-radius:14px;border:1px solid var(--line);margin-top:10px;}
    .mapCard{margin-top:14px;}
    @media(max-width:980px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <header class="card">
      <h1>VPRM01 - GPS Fotos → Excel + KMZ (Local)</h1>
      <p class="muted">Un solo archivo HTML. Mapa gratis (Leaflet + OSM). Exporta Excel + KMZ. Lector EXIF: <b>exifr FULL</b> + <b>exifr.gps()</b>.</p>
    </header>

    <main class="grid">
      <section class="card">
        <h2>1) Proyecto</h2>
        <label>Nombre del proyecto</label>
        <input id="projectName" value="VPRM01" />
        <p class="muted">Nombre usado para los archivos exportados.</p>
      </section>

      <section class="card">
        <h2>2) Cargar ZIP</h2>
        <p class="muted">Sube un <b>.zip</b> con fotos JPG originales (con EXIF).</p>
        <input id="zipFile" type="file" accept=".zip" />
        <button id="btnScan">Analizar ZIP</button>
        <p class="muted" id="scanInfo"></p>

        <div class="stats" id="quality" hidden>
          <div><b>GPS válidos:</b> <span id="qGpsOk">-</span></div>
          <div><b>GPS inválidos/0,0:</b> <span id="qGpsBad">-</span></div>
          <div><b>Duplicados:</b> <span id="qDup">-</span></div>
        </div>
      </section>

      <section class="card">
        <h2>3) Exportar</h2>
        <button id="btnExport" class="primary" disabled>Generar Excel + KMZ</button>

        <div class="stats" id="stats" hidden>
          <div><b>Total imágenes:</b> <span id="stTotal">-</span></div>
          <div><b>GPS válido:</b> <span id="stGPS">-</span></div>
          <div><b>Distancia total aprox:</b> <span id="stDist">-</span> m</div>
        </div>

        <div class="actions" id="downloads" hidden>
          <a id="dlExcel" class="linkbtn" href="#" download>Descargar Excel</a>
          <a id="dlKMZ" class="linkbtn" href="#" download>Descargar KMZ</a>
        </div>

        <p class="muted" id="exportInfo"></p>
      </section>
    </main>

    <section class="card mapCard">
      <h2>Mapa (OpenStreetMap - Gratis)</h2>
      <p class="muted">Puntos + ruta (línea) + perímetro (convex hull). Se ignoran coordenadas 0,0 y fuera de rango.</p>
      <div id="map"></div>
      <div class="muted" id="mapInfo"></div>
    </section>
  </div>

  <!-- Librerías -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- IMPORTANTE: FULL (no lite) -->
  <script src="https://cdn.jsdelivr.net/npm/exifr@7.1.3/dist/full.umd.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);

    // ---------- MAPA ----------
    const map = L.map("map").setView([3.4516, -76.5320], 12);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19, attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    const layerPoints = L.layerGroup().addTo(map);
    let layerRoute = null;
    let layerPerimeter = null;

    function escapeHtml(s) {
      return (s ?? "").toString()
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function centerOn(points) {
      const valid = points.filter(p => typeof p.lat === "number" && typeof p.lon === "number");
      if (!valid.length) return;
      const bounds = L.latLngBounds(valid.map(p => [p.lat, p.lon]));
      map.fitBounds(bounds, { padding: [20, 20] });
    }

    function paintMap(points, routeLine, perimeterPoly) {
      layerPoints.clearLayers();
      if (layerRoute) { map.removeLayer(layerRoute); layerRoute = null; }
      if (layerPerimeter) { map.removeLayer(layerPerimeter); layerPerimeter = null; }

      const valid = points.filter(p => typeof p.lat === "number" && typeof p.lon === "number");
      if (!valid.length) { $("mapInfo").textContent = "No hay puntos GPS válidos."; return; }

      valid.forEach(p => {
        const popup = `<b>${escapeHtml(p.file)}</b><br/>${escapeHtml(p.datetime||"")}<br/>${p.lat}, ${p.lon}<br/>Duplicado: <b>${p.isDuplicate?"SI":"NO"}</b>`;
        L.marker([p.lat, p.lon]).addTo(layerPoints).bindPopup(popup);
      });

      if (routeLine && routeLine.length >= 2) {
        layerRoute = L.polyline(routeLine.map(p => [p.lat, p.lon]), { weight: 3, opacity: 0.9 }).addTo(map);
      }
      if (perimeterPoly && perimeterPoly.length >= 3) {
        layerPerimeter = L.polygon(perimeterPoly.map(p => [p.lat, p.lon]), { weight: 2, opacity: 0.9, fillOpacity: 0.10 }).addTo(map);
      }

      centerOn(valid);
      $("mapInfo").textContent = `Puntos válidos: ${valid.length} | Ruta: ${routeLine?.length||0} | Perímetro: ${perimeterPoly?.length||0}`;
    }

    // ---------- Validación GPS ----------
    function isValidLatLon(lat, lon){
      if (typeof lat !== "number" || typeof lon !== "number") return false;
      if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;
      if (lat === 0 && lon === 0) return false;
      if (lat < -90 || lat > 90) return false;
      if (lon < -180 || lon > 180) return false;
      return true;
    }

    // ---------- Distancias ----------
    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    // ---------- DMS ----------
    function decimalToDMS(dd, isLat) {
      if (typeof dd !== "number" || !Number.isFinite(dd)) return "";
      const dir = isLat ? (dd >= 0 ? "N" : "S") : (dd >= 0 ? "E" : "W");
      const abs = Math.abs(dd);
      const deg = Math.floor(abs);
      const minFloat = (abs - deg) * 60;
      const min = Math.floor(minFloat);
      const sec = (minFloat - min) * 60;
      return `${deg}° ${min}' ${sec.toFixed(4)}" ${dir}`;
    }

    // ---------- Convex Hull (perímetro) ----------
    function convexHull(points){
      const pts = points.map(p => ({x:p.lon, y:p.lat, lat:p.lat, lon:p.lon}));
      if (pts.length < 3) return pts.map(p => ({lat:p.lat, lon:p.lon}));
      pts.sort((a,b) => a.x === b.x ? a.y - b.y : a.x - b.x);
      const cross = (o,a,b) => (a.x-o.x)*(b.y-o.y) - (a.y-o.y)*(b.x-o.x);
      const lower = [];
      for (const p of pts) { while (lower.length>=2 && cross(lower.at(-2), lower.at(-1), p) <= 0) lower.pop(); lower.push(p); }
      const upper = [];
      for (let i=pts.length-1;i>=0;i--) { const p=pts[i]; while (upper.length>=2 && cross(upper.at(-2), upper.at(-1), p) <= 0) upper.pop(); upper.push(p); }
      upper.pop(); lower.pop();
      return lower.concat(upper).map(p => ({lat:p.lat, lon:p.lon}));
    }

    function parseDateTimeForSort(s) {
      if (!s) return null;
      const str = (""+s).trim();
      const norm = str.replace(/^(\d{4}):(\d{2}):(\d{2})/, "$1-$2-$3");
      const d = new Date(norm);
      return isNaN(d.getTime()) ? null : d.getTime();
    }

    function sortRows(rows){
      return rows.slice().sort((a,b) => {
        const ta = parseDateTimeForSort(a.datetime);
        const tb = parseDateTimeForSort(b.datetime);
        if (ta != null && tb != null) return ta - tb;
        if (ta != null && tb == null) return -1;
        if (ta == null && tb != null) return 1;
        return (a.file || "").localeCompare(b.file || "");
      });
    }

    function computeDuplicates(validRows){
      const seen = new Map();
      let dup = 0;
      validRows.forEach(r => {
        const key = `${r.lat.toFixed(6)},${r.lon.toFixed(6)}`;
        if (seen.has(key)) { r.isDuplicate = true; dup++; }
        else { r.isDuplicate = false; seen.set(key,true); }
      });
      return dup;
    }

    function computeDistancesInOrder(validRowsOrdered){
      let total = 0;
      let prev = null;
      validRowsOrdered.forEach(r => {
        if (!prev) { r.distFromPrevM = 0; r.distAccumM = 0; prev = r; return; }
        const d = haversineMeters(prev.lat, prev.lon, r.lat, r.lon);
        total += d;
        r.distFromPrevM = d;
        r.distAccumM = total;
        prev = r;
      });
      return total;
    }

    // ---------- Estado ----------
    let analyzedRows = [];
    let totalDistance = 0;

    function getProjectName() {
      return ($("projectName").value || "").trim() || "VPRM01";
    }

    // ---------- Analizar ZIP usando EXIFR FULL + exifr.gps ----------
    $("btnScan").addEventListener("click", async () => {
      try {
        const file = $("zipFile").files[0];
        if (!file) throw new Error("Selecciona un .zip con fotos JPG.");

        $("scanInfo").textContent = "Leyendo ZIP...";
        $("downloads").hidden = true;
        $("stats").hidden = true;
        $("quality").hidden = true;
        $("btnExport").disabled = true;

        analyzedRows = [];
        totalDistance = 0;

        const zip = await JSZip.loadAsync(file);
        const imgEntries = [];
        zip.forEach((path, entry) => {
          const low = path.toLowerCase();
          if (!entry.dir && (low.endsWith(".jpg") || low.endsWith(".jpeg"))) imgEntries.push(entry);
        });
        if (!imgEntries.length) throw new Error("El ZIP no contiene .jpg/.jpeg.");

        let gpsOk = 0, gpsBad = 0;

        $("scanInfo").textContent = `Encontradas ${imgEntries.length} imágenes. Analizando EXIF (exifr.gps)...`;

        for (let i=0;i<imgEntries.length;i++){
          const entry = imgEntries[i];
          const ab = await entry.async("arraybuffer");
          const fileOnly = entry.name.split("/").pop();

          const row = {
            file: fileOnly,
            relPath: entry.name,
            datetime: "",
            lat: null, lon: null, alt: null,
            make: "", model: "",
            gpsValid: false,
            isDuplicate: false,
            distFromPrevM: 0,
            distAccumM: 0
          };

          let gps = null;
          let meta = null;

          // 1) GPS (más confiable)
          try { gps = await exifr.gps(ab); } catch (e) {}

          // 2) Metadata general
          try {
            meta = await exifr.parse(ab, { exif:true, ifd0:true, tiff:true });
          } catch (e) {}

          if (meta) {
            const dt = meta.DateTimeOriginal || meta.CreateDate || meta.ModifyDate || meta.DateTime;
            if (dt instanceof Date) {
              const pad = n => String(n).padStart(2,"0");
              row.datetime = `${dt.getFullYear()}:${pad(dt.getMonth()+1)}:${pad(dt.getDate())} ${pad(dt.getHours())}:${pad(dt.getMinutes())}:${pad(dt.getSeconds())}`;
            } else if (dt) {
              row.datetime = String(dt);
            }
            if (meta.Make) row.make = String(meta.Make);
            if (meta.Model) row.model = String(meta.Model);
          }

          if (gps && typeof gps.latitude === "number" && typeof gps.longitude === "number") {
            row.lat = gps.latitude;
            row.lon = gps.longitude;
            if (typeof gps.altitude === "number") row.alt = gps.altitude;
          }

          if (isValidLatLon(row.lat, row.lon)) { row.gpsValid = true; gpsOk++; }
          else {
            // si había algo pero inválido
            if (row.lat != null || row.lon != null) gpsBad++;
            row.lat = null; row.lon = null; row.alt = null; row.gpsValid = false;
          }

          analyzedRows.push(row);

          if ((i+1)%25===0 || i===imgEntries.length-1){
            $("scanInfo").textContent = `Analizadas ${i+1}/${imgEntries.length} | GPS válido: ${gpsOk} | inválido/0,0: ${gpsBad}`;
            await new Promise(r => setTimeout(r, 0));
          }
        }

        // Orden, duplicados, distancias
        const ordered = sortRows(analyzedRows);
        const gpsRows = ordered.filter(r => r.gpsValid);
        const dupCount = computeDuplicates(gpsRows);
        totalDistance = computeDistancesInOrder(gpsRows);

        const routePoints = gpsRows.map(r => ({lat:r.lat, lon:r.lon, file:r.file, datetime:r.datetime, isDuplicate:r.isDuplicate}));
        const perimeterPoints = convexHull(routePoints);

        paintMap(
          gpsRows.map(r => ({lat:r.lat, lon:r.lon, file:r.file, datetime:r.datetime, isDuplicate:r.isDuplicate})),
          routePoints,
          perimeterPoints
        );

        $("stTotal").textContent = analyzedRows.length;
        $("stGPS").textContent = gpsRows.length;
        $("stDist").textContent = Math.round(totalDistance);

        $("qGpsOk").textContent = gpsOk;
        $("qGpsBad").textContent = gpsBad;
        $("qDup").textContent = dupCount;

        $("stats").hidden = false;
        $("quality").hidden = false;
        $("btnExport").disabled = false;

        $("scanInfo").textContent = `Listo ✅ Total: ${analyzedRows.length} | GPS válido: ${gpsRows.length} | Duplicados: ${dupCount}`;

      } catch (e) {
        $("scanInfo").textContent = "⚠ " + e.message;
      }
    });

    // ---------- Exportar Excel + KMZ ----------
    $("btnExport").addEventListener("click", async () => {
      try {
        if (!analyzedRows.length) throw new Error("Primero analiza un ZIP.");

        const project = getProjectName();
        $("exportInfo").textContent = "Generando Excel + KMZ...";

        const rowsOrdered = sortRows(analyzedRows);
        const gpsRowsOrdered = rowsOrdered.filter(r => r.gpsValid);
        computeDuplicates(gpsRowsOrdered);
        totalDistance = computeDistancesInOrder(gpsRowsOrdered);

        // Excel
        const header = [
          "Archivo","RutaRelativa","FechaHora",
          "LatitudDecimal","LongitudDecimal","Altitud",
          "LatitudDMS","LongitudDMS",
          "Marca","Modelo",
          "LinkGoogleMaps","Duplicado",
          "DistanciaDesdeAnterior_m","DistanciaAcumulada_m",
          "GPS_Valido"
        ];

        const data = [header];
        rowsOrdered.forEach(r => {
          const link = r.gpsValid ? `https://www.google.com/maps?q=${r.lat},${r.lon}` : "";
          data.push([
            r.file, r.relPath, r.datetime || "",
            r.gpsValid ? r.lat : "", r.gpsValid ? r.lon : "", (r.alt ?? ""),
            r.gpsValid ? decimalToDMS(r.lat,true) : "", r.gpsValid ? decimalToDMS(r.lon,false) : "",
            r.make || "", r.model || "",
            link,
            r.gpsValid ? (r.isDuplicate ? "SI":"NO") : "",
            r.gpsValid ? Math.round(r.distFromPrevM||0) : "",
            r.gpsValid ? Math.round(r.distAccumM||0) : "",
            r.gpsValid ? "SI":"NO"
          ]);
        });

        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(data);
        ws["!cols"] = header.map(h => ({ wch: Math.min(Math.max(h.length+2, 16), 38) }));
        XLSX.utils.book_append_sheet(wb, ws, "Coordenadas");
        const xlsxArray = XLSX.write(wb, { bookType: "xlsx", type: "array" });
        const xlsxBlob = new Blob([xlsxArray], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });

        // KMZ
        const placemarks = gpsRowsOrdered.map(r => {
          const name = escapeHtml(r.file);
          const desc = escapeHtml(
            `FechaHora: ${r.datetime||""}\n`+
            `Marca/Modelo: ${(r.make||"")} ${(r.model||"")}\n`+
            `Altitud: ${r.alt ?? ""}\n`+
            `Duplicado: ${r.isDuplicate?"SI":"NO"}\n`+
            `DistAcum_m: ${Math.round(r.distAccumM||0)}\n`+
            `Ruta: ${r.relPath}`
          );
          const alt = (typeof r.alt === "number") ? r.alt : 0;
          return `
  <Placemark>
    <name>${name}</name>
    <description><![CDATA[${desc}]]></description>
    <Point><coordinates>${r.lon},${r.lat},${alt}</coordinates></Point>
  </Placemark>`;
        }).join("\n");

        const lineCoords = gpsRowsOrdered.map(r => `${r.lon},${r.lat},0`).join(" ");
        const lineString = (gpsRowsOrdered.length >= 2) ? `
  <Placemark>
    <name>${escapeHtml(project)}_RUTA</name>
    <LineString><tessellate>1</tessellate><coordinates>${lineCoords}</coordinates></LineString>
  </Placemark>` : "";

        const hull = convexHull(gpsRowsOrdered.map(r => ({lat:r.lat, lon:r.lon})));
        let polygon = "";
        if (hull.length >= 3) {
          const polyCoords = hull.map(p => `${p.lon},${p.lat},0`).join(" ");
          const first = hull[0];
          polygon = `
  <Placemark>
    <name>${escapeHtml(project)}_PERIMETRO</name>
    <Polygon><tessellate>1</tessellate>
      <outerBoundaryIs><LinearRing>
        <coordinates>${polyCoords} ${first.lon},${first.lat},0</coordinates>
      </LinearRing></outerBoundaryIs>
    </Polygon>
  </Placemark>`;
        }

        const kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2"><Document>
  <name>${escapeHtml(project)}</name>
${placemarks}
${lineString}
${polygon}
</Document></kml>`;

        const kmzZip = new JSZip();
        kmzZip.file("doc.kml", kml);
        const kmzBlob = await kmzZip.generateAsync({ type: "blob" });

        // Descargas
        const excelUrl = URL.createObjectURL(xlsxBlob);
        const kmzUrl = URL.createObjectURL(kmzBlob);

        $("dlExcel").href = excelUrl;
        $("dlExcel").download = `${project}_coordenadas.xlsx`;

        $("dlKMZ").href = kmzUrl;
        $("dlKMZ").download = `${project}_mapa.kmz`;

        $("downloads").hidden = false;
        $("exportInfo").textContent = "Listo ✅ Excel + KMZ generados.";

      } catch (e) {
        $("exportInfo").textContent = "⚠ " + e.message;
      }
    });
  </script>
</body>
</html>
